package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

/* ============================ create-outbound ============================ */

func runCreateOutbound(pkg, method string, withParam, withResp bool) error {
	// 1) ensure base package exists with port.go + impl.go
	if err := ensureOutboundPkg(pkg); err != nil {
		return err
	}

	// 2) If a method is provided, extend interface + impl and manage DTOs
	if method != "" {
		if err := ensureOutboundPortHasMethod(pkg, method, withParam, withResp); err != nil {
			return err
		}
		if err := ensureOutboundDTO(pkg, method, withParam, withResp); err != nil {
			return err
		}
		if err := ensureOutboundImplHasMethod(pkg, method, withParam, withResp); err != nil {
			return err
		}
	}

	return nil
}

/* ---------- package skeleton ---------- */

func ensureOutboundPkg(pkg string) error {
	mod := modulePathGuess()
	dir := filepath.Join(outboundRootPath, pkg)
	if _, err := os.Stat(dir); errors.Is(err, os.ErrNotExist) {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	// port.go
	if err := ensureOutboundPort(pkg); err != nil {
		return err
	}

	// impl.go
	implPath := filepath.Join(dir, "impl.go")
	if _, err := os.Stat(implPath); errors.Is(err, os.ErrNotExist) {
		iface := toExport(pkg)
		body := fmt.Sprintf(`package %s

import (
	"%s/internal/infrastructure/config"
	"github.com/AndreeJait/go-utility/loggerw"
)

type impl struct {
	logger loggerw.Logger
	cfg    *config.Config
}

func New%[2]sW(log loggerw.Logger, cfg *config.Config) %[2]s {
	return &impl{logger: log, cfg: cfg}
}
`, pkg, iface, mod)
		return writeGoFile(implPath, body)
	}
	return nil
}

func ensureOutboundPort(pkg string) error {
	iface := toExport(pkg)
	path := filepath.Join(outboundRootPath, pkg, "port.go")
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		body := fmt.Sprintf(`package %s

type %s interface {
}
`, pkg, iface)
		return writeGoFile(path, body)
	}
	return nil
}

/* ---------- port method ---------- */

func ensureOutboundPortHasMethod(pkg, method string, withParam, withResp bool) error {
	iface := toExport(pkg)
	path := filepath.Join(outboundRootPath, pkg, "port.go")

	// Read (must exist from skeleton)
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	// Imports: add "context" if missing and any method will use it
	if !strings.Contains(src, "import (") && !strings.Contains(src, `import "context"`) {
		// add a single import
		// place after package line
		nl := strings.Index(src, "\n")
		src = src[:nl+1] + `import "context"` + "\n" + src[nl+1:]
	} else if strings.Contains(src, "import (") && !strings.Contains(src, `"context"`) {
		src = insertImport(src, `"context"`)
	}

	// method signature
	req := "ctx context.Context"
	if withParam {
		req += ", req " + method + "Request"
	}
	ret := "error"
	if withResp {
		ret = "(" + method + "Response, error)"
	}
	newLine := fmt.Sprintf("\t%s(%s) %s\n", method, req, ret)

	// find iface block, create if missing
	start := strings.Index(src, "type "+iface+" interface {")
	if start == -1 {
		// create a new interface definition
		src = strings.TrimRight(src, "\n") + "\n" + fmt.Sprintf("type %s interface {\n%s}\n", iface, newLine)
		return writeGoFile(path, src)
	}

	// insert inside the interface if not yet present
	end := strings.Index(src[start:], "}")
	if end == -1 {
		// malformed; close then append
		src += "\n}\n"
		end = strings.LastIndex(src, "}")
	}
	block := src[start : start+end]
	if !strings.Contains(block, method+"(") {
		insertAt := start + end
		src = src[:insertAt] + "\n" + newLine + src[insertAt:]
	}

	return writeGoFile(path, src)
}

/* ---------- dto ---------- */

func ensureOutboundDTO(pkg, method string, withParam, withResp bool) error {
	path := filepath.Join(outboundRootPath, pkg, "dto.go")
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		if err := writeGoFile(path, "package "+pkg+"\n\n"); err != nil {
			return err
		}
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	if withParam && !strings.Contains(src, "type "+method+"Request struct") {
		src += fmt.Sprintf("\n// %sRequest generated by ntaps\ntype %sRequest struct {\n\t// TODO: define fields\n}\n", method, method)
	}
	if withResp && !strings.Contains(src, "type "+method+"Response struct") {
		src += fmt.Sprintf("\n// %sResponse generated by ntaps\ntype %sResponse struct {\n\t// TODO: define fields\n}\n", method, method)
	}

	return writeGoFile(path, src)
}

/* ---------- impl method ---------- */

func ensureOutboundImplHasMethod(pkg, method string, withParam, withResp bool) error {
	mod := modulePathGuess()
	path := filepath.Join(outboundRootPath, pkg, "impl.go")

	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	// ensure required imports
	need := []string{
		`"context"`,
		`"github.com/AndreeJait/go-utility/tracer"`,
		fmt.Sprintf(`"%s/internal/infrastructure/config"`, mod),
		`"github.com/AndreeJait/go-utility/loggerw"`,
	}
	for _, imp := range need {
		if !strings.Contains(src, imp) {
			src = insertImport(src, imp)
		}
	}

	// if method exists, skip
	sig := fmt.Sprintf("func (i *impl) %s(", method)
	if strings.Contains(src, sig) {
		return writeGoFile(path, src)
	}

	// signature pieces
	args := "ctx context.Context"
	if withParam {
		args += ", req " + method + "Request"
	}
	ret := "error"
	var retBody string
	if withResp {
		ret = "(" + method + "Response, error)"
		retBody = "var resp " + method + "Response\n\t// TODO: implement\n\treturn resp, nil"
	} else {
		retBody = "// TODO: implement\n\treturn nil"
	}

	// method body with tracer
	methodSrc := fmt.Sprintf(`

func (i *impl) %s(%s) %s {
	span, ctx := tracer.StartSpan(ctx, tracer.GetFuncName(i.%s))
	defer span.End()

	%s
}
`, method, args, ret, method, retBody)

	src += methodSrc
	return writeGoFile(path, src)
}
