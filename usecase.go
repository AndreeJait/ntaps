package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

/* ============================ create-usecase ============================ */

func runCreateUsecase(pkg, method string, withParam, withResp bool) error {
	pkgDir := filepath.Join(rootUsecaseDir, pkg)

	if _, err := os.Stat(pkgDir); errors.Is(err, os.ErrNotExist) {
		if err := os.MkdirAll(pkgDir, 0o755); err != nil {
			return fmt.Errorf("mkdir %s: %w", pkgDir, err)
		}
		if err := createPortGo(pkgDir, pkg, method, withParam, withResp); err != nil {
			return err
		}
		if err := createDTOGo(pkgDir, pkg, method, withParam, withResp, false); err != nil {
			return err
		}
		if err := createUsecaseGo(pkgDir, pkg, method, withParam, withResp); err != nil {
			return err
		}
		if err := updateUsecaseDI(pkg); err != nil {
			return err
		}
		if err := updateInfraInitUsecase(pkg); err != nil {
			return err
		}
		return nil
	}

	// package exists â†’ extend safely
	if err := ensurePortHasMethod(filepath.Join(pkgDir, "port.go"), pkg, method, withParam, withResp); err != nil {
		return err
	}
	if err := ensureDTO(pkgDir, pkg, method, withParam, withResp); err != nil {
		return err
	}
	if err := ensureUsecaseImpl(pkgDir, pkg, method, withParam, withResp); err != nil {
		return err
	}
	if err := updateUsecaseDI(pkg); err != nil {
		return err
	}
	if err := updateInfraInitUsecase(pkg); err != nil {
		return err
	}
	return nil
}

/* ---------- port.go ---------- */

func ensurePortHasMethod(path, pkg, method string, withParam, withResp bool) error {
	req := "ctx context.Context"
	ret := "error"
	if withParam {
		req += ", req " + method + "Request"
	}
	if withResp {
		ret = "(" + method + "Response, error)"
	}
	newLine := fmt.Sprintf("\t%s(%s) %s\n", method, req, ret)

	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		return writeGoFile(path, renderPortGo(pkg, method, withParam, withResp))
	}

	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	if !strings.Contains(src, "package "+pkg) {
		src = "package " + pkg + "\n\n" + src
	}
	if !strings.Contains(src, `import "context"`) && !strings.Contains(src, "import (") {
		afterPkg := strings.Index(src, "\n")
		src = src[:afterPkg+1] + `import "context"` + "\n" + src[afterPkg+1:]
	}

	start := strings.Index(src, "type UseCase interface {")
	if start == -1 {
		src = strings.TrimRight(src, "\n") + "\n\ntype UseCase interface {\n" + newLine + "}\n"
		return writeGoFile(path, src)
	}
	end := strings.Index(src[start:], "}")
	if end == -1 {
		src += "\n}\n"
		end = strings.LastIndex(src, "}")
	}
	block := src[start : start+end]
	if strings.Contains(block, method+"(") {
		return writeGoFile(path, src)
	}
	insertPos := start + end
	src = src[:insertPos] + "\n" + newLine + src[insertPos:]
	return writeGoFile(path, src)
}

func createPortGo(dir, pkg, method string, withParam, withResp bool) error {
	path := filepath.Join(dir, "port.go")
	if _, err := os.Stat(path); err == nil {
		return ensurePortHasMethod(path, pkg, method, withParam, withResp)
	}
	return writeGoFile(path, renderPortGo(pkg, method, withParam, withResp))
}

func renderPortGo(pkg, method string, withParam, withResp bool) string {
	req := "ctx context.Context"
	ret := "error"
	if withParam {
		req += ", req " + method + "Request"
	}
	if withResp {
		ret = "(" + method + "Response, error)"
	}

	return fmt.Sprintf(`package %s

import "context"

type UseCase interface {
	%s(%s) %s
}
`, pkg, method, req, ret)
}

/* ---------- dto.go ---------- */

func createDTOGo(dir, pkg, method string, withParam, withResp bool, appendOnly bool) error {
	path := filepath.Join(dir, "dto.go")
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		var b bytes.Buffer
		b.WriteString("package " + pkg + "\n\n")
		if withParam {
			b.WriteString(fmt.Sprintf("type %sRequest struct {\n\t// TODO: define fields\n}\n\n", method))
		}
		if withResp {
			b.WriteString(fmt.Sprintf("type %sResponse struct {\n\t// TODO: define fields\n}\n\n", method))
		}
		return writeGoFile(path, b.String())
	}
	if appendOnly {
		return appendDTO(path, method, withParam, withResp)
	}
	return nil
}

func ensureDTO(dir, pkg, method string, withParam, withResp bool) error {
	return createDTOGo(dir, pkg, method, withParam, withResp, true)
}

func appendDTO(path, method string, withParam, withResp bool) error {
	src, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	out := string(src)
	if withParam && !strings.Contains(out, "type "+method+"Request struct") {
		out += fmt.Sprintf("\n// %sRequest generated by ntaps\ntype %sRequest struct {\n\t// TODO: define fields\n}\n", method, method)
	}
	if withResp && !strings.Contains(out, "type "+method+"Response struct") {
		out += fmt.Sprintf("\n// %sResponse generated by ntaps\ntype %sResponse struct {\n\t// TODO: define fields\n}\n", method, method)
	}
	return writeGoFile(path, out)
}

/* ---------- usecase.go (impl) ---------- */

func createUsecaseGo(dir, pkg, method string, withParam, withResp bool) error {
	path := filepath.Join(dir, "usecase.go")
	if _, err := os.Stat(path); err == nil {
		return nil
	}
	body := renderUsecaseGo(pkg, method, withParam, withResp)
	return writeGoFile(path, body)
}

func renderUsecaseGo(pkg, method string, withParam, withResp bool) string {
	mp := modulePathGuess()

	sigIn := "ctx context.Context"
	if withParam {
		sigIn += ", req " + method + "Request"
	}
	ret := "error"
	if withResp {
		ret = "(" + method + "Response, error)"
	}
	var retBody string
	if withResp {
		retBody = "var resp " + method + "Response\n\t// TODO: implement\n\treturn resp, nil"
	} else {
		retBody = "// TODO: implement\n\treturn nil"
	}

	return fmt.Sprintf(`package %s

import (
	"context"
	"time"
	"github.com/AndreeJait/go-utility/loggerw"

	"%s/internal/infrastructure/config"
	"%s/internal/infrastructure/db"
	"github.com/AndreeJait/go-utility/tracer"
)

// useCase implements UseCase.
type useCase struct {
	cfg       *config.Config
	log       loggerw.Logger
	txManager *db.TxManager
}

func NewUseCase(cfg *config.Config, log loggerw.Logger, txManager *db.TxManager) UseCase {
	return &useCase{cfg: cfg, log: log, txManager: txManager}
}

func (u *useCase) %s(%s) %s {
	span, ctx := tracer.StartSpan(ctx, tracer.GetFuncName(u.%s))
	defer span.End()

	_ = time.Second // keep import 'time' warm; remove when used

	%s
}
`, pkg, mp, mp, method, sigIn, ret, method, retBody)
}

func ensureUsecaseImpl(dir, pkg, method string, withParam, withResp bool) error {
	path := filepath.Join(dir, "usecase.go")
	src, err := os.ReadFile(path)
	if errors.Is(err, os.ErrNotExist) {
		return createUsecaseGo(dir, pkg, method, withParam, withResp)
	}
	if err != nil {
		return err
	}
	body := string(src)
	mp := modulePathGuess()

	required := []string{
		fmt.Sprintf(`"%s/internal/infrastructure/config"`, mp),
		fmt.Sprintf(`"%s/internal/infrastructure/db"`, mp),
		`"github.com/AndreeJait/go-utility/loggerw"`,
		`"github.com/AndreeJait/go-utility/tracer"`,
		`"context"`,
		`"time"`,
	}
	for _, imp := range required {
		if !strings.Contains(body, imp) {
			body = insertImport(body, imp)
		}
	}

	if !strings.Contains(body, "type useCase struct") {
		body += `
type useCase struct {
	cfg       *config.Config
	log       loggerw.Logger
	txManager *db.TxManager
}

func NewUseCase(cfg *config.Config, log loggerw.Logger, txManager *db.TxManager) UseCase {
	return &useCase{cfg: cfg, log: log, txManager: txManager}
}
`
	} else {
		body = strings.ReplaceAll(body, "txManager  db.TxManager", "txManager *db.TxManager")
		body = strings.ReplaceAll(body, "txManager db.TxManager", "txManager *db.TxManager")
		body = strings.ReplaceAll(body, "NewUseCase(cfg *config.Config, log loggerw.Logger, txManager db.TxManager)", "NewUseCase(cfg *config.Config, log loggerw.Logger, txManager *db.TxManager)")
	}

	methodSig := fmt.Sprintf("func (u *useCase) %s(", method)
	if !strings.Contains(body, methodSig) {
		sigIn := "ctx context.Context"
		if withParam {
			sigIn += ", req " + method + "Request"
		}
		ret := "error"
		if withResp {
			ret = "(" + method + "Response, error)"
		}
		var retBody string
		if withResp {
			retBody = "var resp " + method + "Response\n\t// TODO: implement\n\treturn resp, nil"
		} else {
			retBody = "// TODO: implement\n\treturn nil"
		}

		body += fmt.Sprintf(`

func (u *useCase) %s(%s) %s {
	span, ctx := tracer.StartSpan(ctx, tracer.GetFuncName(u.%s))
	defer span.End()

	%s
}
`, method, sigIn, ret, method, retBody)
	}
	return writeGoFile(path, body)
}

/* ---------- DI wiring for usecase ---------- */

func updateUsecaseDI(pkg string) error {
	if _, err := os.Stat(usecaseDIPath); errors.Is(err, os.ErrNotExist) {
		content := fmt.Sprintf(`package usecase

import (
	"%s/internal/usecase/%s"
)

type UseCase struct {
	%sUc %s.UseCase
}
`, modulePathGuess(), pkg, toExport(pkg), pkg)
		return writeGoFile(usecaseDIPath, content)
	}

	src, err := os.ReadFile(usecaseDIPath)
	if err != nil {
		return err
	}
	body := string(src)
	importLine := fmt.Sprintf(`"%s/internal/usecase/%s"`, modulePathGuess(), pkg)

	if !strings.Contains(body, importLine) {
		body = insertImport(body, importLine)
	}
	field := fmt.Sprintf("\t%sUc %s.UseCase", toExport(pkg), pkg)
	if !strings.Contains(body, field) {
		body = strings.Replace(body, "type UseCase struct {", "type UseCase struct {\n"+field+"\n", 1)
	}
	return writeGoFile(usecaseDIPath, body)
}

func updateInfraInitUsecase(pkg string) error {
	if _, err := os.Stat(infraInitUsecasePath); err != nil {
		return fmt.Errorf("cannot find %s (needed to wire initUseCase)", infraInitUsecasePath)
	}
	src, err := os.ReadFile(infraInitUsecasePath)
	if err != nil {
		return err
	}
	body := string(src)

	importLine := fmt.Sprintf(`"%s/internal/usecase/%s"`, modulePathGuess(), pkg)
	if !strings.Contains(body, importLine) {
		body = insertImport(body, importLine)
	}
	if !strings.Contains(body, "func (s wire) initUseCase(") && !strings.Contains(body, "func (s wire) initUseCase()") {
		body += `

func (s wire) initUseCase() {
	// generated by ntaps
}
`
	}

	assign := fmt.Sprintf(`s.uc.%sUc = %s.NewUseCase(s.cfg, s.log, s.repo.TxManager)`, toExport(pkg), pkg)
	if !strings.Contains(body, assign) {
		re := regexp.MustCompile(`func \(s\s+wire\)\s+initUseCase\([^\)]*\)\s*\{`)
		loc := re.FindStringIndex(body)
		if loc == nil {
			return fmt.Errorf("initUseCase() not found in %s", infraInitUsecasePath)
		}
		insertAt := loc[1]
		body = body[:insertAt] + "\n\t" + assign + "\n" + body[insertAt:]
	}
	return writeGoFile(infraInitUsecasePath, body)
}
