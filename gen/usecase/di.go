package usecase

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/AndreeJait/ntaps/internal/paths"
	"github.com/AndreeJait/ntaps/internal/util"
)

func updateUsecaseDI(pkg string) error {
	path := paths.UsecaseDIPath

	if _, err := os.Stat(path); os.IsNotExist(err) {
		content := fmt.Sprintf(`package usecase

import (
	"%s/internal/usecase/%s"
)

type UseCase struct {
	%sUc %s.UseCase
}
`, util.ModulePathGuess(), pkg, util.ToPascalCase(pkg), pkg)
		return util.WriteGoFile(path, content)
	}

	raw, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	body := string(raw)

	importLine := fmt.Sprintf(`"%s/internal/usecase/%s"`, util.ModulePathGuess(), pkg)
	if !strings.Contains(body, importLine) {
		body = util.InsertImport(body, importLine)
	}

	field := fmt.Sprintf("\t%sUc %s.UseCase", util.ToPascalCase(pkg), pkg)
	if !strings.Contains(body, field) {
		body = strings.Replace(body,
			"type UseCase struct {",
			"type UseCase struct {\n"+field+"\n",
			1,
		)
	}
	return util.WriteGoFile(path, body)
}

func updateInfraInitUsecase(pkg string) error {
	path := paths.InfraInitUsecasePath

	raw, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("cannot read %s: %w", path, err)
	}
	body := string(raw)

	// 1. ensure import of this usecase pkg
	importLine := fmt.Sprintf(`"%s/internal/usecase/%s"`, util.ModulePathGuess(), pkg)
	if !strings.Contains(body, importLine) {
		body = util.InsertImport(body, importLine)
	}

	// 2. ensure initUseCase() exists
	if !strings.Contains(body, "func (s wire) initUseCase(") &&
		!strings.Contains(body, "func (s wire) initUseCase()") {
		body += `

func (s wire) initUseCase() {
	// generated by ntaps
}
`
	}

	// 3. determine the default assignment line
	assignLine := fmt.Sprintf(
		`s.uc.%sUc = %s.NewUseCase(s.cfg, s.log, s.repo.TxManager)`,
		util.ToPascalCase(pkg),
		pkg,
	)

	// 4. check if this UC is already assigned anywhere
	alreadyAssignedRe := regexp.MustCompile(
		fmt.Sprintf(`s\.uc\.%sUc\s*=\s*`, util.ToPascalCase(pkg)),
	)
	if alreadyAssignedRe.MatchString(body) {
		// already wired, no duplicate insert
		return util.WriteGoFile(path, body)
	}

	// 5. inject the default assignment in initUseCase()
	fnHeaderRe := regexp.MustCompile(`func\s+\(s\s+wire\)\s+initUseCase\([^\)]*\)\s*\{`)
	loc := fnHeaderRe.FindStringIndex(body)
	if loc == nil {
		return fmt.Errorf("initUseCase() not found in %s", path)
	}
	insertAt := loc[1]

	body = body[:insertAt] + "\n\t" + assignLine + "\n" + body[insertAt:]

	return util.WriteGoFile(path, body)
}

// EnsureUsecaseKnownToDI exposes the "make sure DI knows this ucPkg"
// behavior for external callers (like AddRepoToUsecase).
// It does NOT create new UC methods.
func EnsureUsecaseKnownToDI(pkg string) error {
	if err := updateUsecaseDI(pkg); err != nil {
		return err
	}
	if err := updateInfraInitUsecase(pkg); err != nil {
		return err
	}
	return nil
}
