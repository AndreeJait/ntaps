package repo

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/AndreeJait/ntaps/internal/paths"
	"github.com/AndreeJait/ntaps/internal/util"
)

func updatePostgresDI(pkg string) error {
	mod := util.ModulePathGuess()
	path := paths.PgDiPath

	if _, err := os.Stat(path); os.IsNotExist(err) {
		content := fmt.Sprintf(`package db

import (
	"%s/internal/adapters/outbound/db/postgres/%s"
	"%s/internal/infrastructure/db"
)

type Repository struct {
	%sRepo *%s.Repository
	TxManager *db.TxManager
}
`, mod, pkg, mod, util.ToPascalCase(pkg), pkg)
		return util.WriteGoFile(path, content)
	}

	raw, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(raw)

	impRepo := fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, pkg)
	if !strings.Contains(src, impRepo) {
		src = util.InsertImport(src, impRepo)
	}
	impDB := fmt.Sprintf(`"%s/internal/infrastructure/db"`, mod)
	if !strings.Contains(src, impDB) {
		src = util.InsertImport(src, impDB)
	}

	field := fmt.Sprintf("\t%sRepo *%s.Repository", util.ToPascalCase(pkg), pkg)
	if !strings.Contains(src, field) {
		src = strings.Replace(src,
			"type Repository struct {",
			"type Repository struct {\n\t// "+util.ToPascalCase(pkg)+"Repo\n"+field,
			1,
		)
	}
	if !strings.Contains(src, "\tTxManager *db.TxManager") {
		src = strings.Replace(src,
			"type Repository struct {",
			"type Repository struct {\n\t// TxManager\n\tTxManager *db.TxManager",
			1,
		)
	}

	return util.WriteGoFile(path, src)
}

func updateInfraRepositoryInit(pkg string) error {
	mod := util.ModulePathGuess()
	path := paths.InfraRepoInitPath

	raw, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("cannot read %s (needed to wire initRepository): %w", path, err)
	}
	src := string(raw)

	impRepo := fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, pkg)
	if !strings.Contains(src, impRepo) {
		src = util.InsertImport(src, impRepo)
	}
	impDB := fmt.Sprintf(`"%s/internal/infrastructure/db"`, mod)
	if !strings.Contains(src, impDB) {
		src = util.InsertImport(src, impDB)
	}

	if !strings.Contains(src, "func (s wire) initRepository(") &&
		!strings.Contains(src, "func (s wire) initRepository()") {
		src += `

func (s wire) initRepository() {
	// generated by ntaps
}
`
	}

	assignRepo := fmt.Sprintf(
		`s.repo.%sRepo = %s.New%sRepository(s.pg)`,
		util.ToPascalCase(pkg), pkg, util.ToPascalCase(pkg),
	)
	assignTx := `s.repo.TxManager = db.NewTxManager(s.pg)`

	re := regexp.MustCompile(`func \(s\s+wire\)\s+initRepository\([^\)]*\)\s*\{`)
	loc := re.FindStringIndex(src)
	if loc == nil {
		return fmt.Errorf("initRepository() not found in %s", path)
	}
	insertAt := loc[1]

	if !strings.Contains(src, assignRepo) {
		src = src[:insertAt] + "\n\t// generated by ntaps\n\t" + assignRepo + src[insertAt:]
	}

	if !strings.Contains(src, assignTx) {
		idx := strings.Index(src, assignRepo)
		if idx != -1 {
			braceIdx := strings.Index(src[idx:], "\n")
			insertAt = idx + braceIdx + 1
		}
		src = src[:insertAt] + "\t" + assignTx + "\n" + src[insertAt:]
	}

	return util.WriteGoFile(path, src)
}

// ---- wiring into usecase for repo ----

func ensureUsecaseRepoInterface(
	ucPkg, repoPkg, method string,
	withParam, withResp, withTx bool,
) error {
	mod := util.ModulePathGuess()
	path := fmt.Sprintf("%s/%s/port.go", paths.RootUsecaseDir, ucPkg)

	if _, err := os.Stat(path); os.IsNotExist(err) {
		if err := util.WriteGoFile(path, "package "+ucPkg+"\n\nimport \"context\"\n\ntype UseCase interface{}\n"); err != nil {
			return err
		}
	}

	raw, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(raw)

	impRepo := fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, repoPkg)
	if !strings.Contains(src, impRepo) {
		src = util.InsertImport(src, impRepo)
	}
	if withTx && !strings.Contains(src, `"github.com/jackc/pgx/v5"`) {
		src = util.InsertImport(src, `"github.com/jackc/pgx/v5"`)
	}
	if !strings.Contains(src, `import "context"`) && !strings.Contains(src, "import (") {
		firstNL := strings.Index(src, "\n")
		src = src[:firstNL+1] + "import \"context\"\n" + src[firstNL+1:]
	}

	ifaceName := "Repo"
	if repoPkg != ucPkg {
		ifaceName = util.ToPascalCase(repoPkg) + "Repo"
	}

	// ensure interface exists
	if !strings.Contains(src, "type "+ifaceName+" interface {") {
		src += "\n" + "type " + ifaceName + " interface {\n}\n"
	}

	// ensure method in that interface
	req := "ctx context.Context"
	if withParam {
		req += fmt.Sprintf(", param %s.%sParam", repoPkg, method)
	}
	if withTx {
		req += ", tx pgx.Tx"
	}
	ret := "error"
	if withResp {
		ret = fmt.Sprintf("(%s.%sResponse, error)", repoPkg, method)
	}

	newLine := fmt.Sprintf("\t%s(%s) %s", method, req, ret)

	start := strings.Index(src, "type "+ifaceName+" interface {")
	if start != -1 {
		end := strings.Index(src[start:], "}")
		if end != -1 {
			block := src[start : start+end]
			if !strings.Contains(block, method+"(") {
				insertAt := start + end
				src = src[:insertAt] + "\t// " + method + " \n" + newLine + "\n" + src[insertAt:]
			}
		}
	}

	return util.WriteGoFile(path, src)
}

func ensureUsecaseHasRepo(ucPkg, repoPkg string) error {
	path := fmt.Sprintf("%s/%s/usecase.go", paths.RootUsecaseDir, ucPkg)
	raw, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(raw)

	iface := "Repo"
	if repoPkg != ucPkg {
		iface = util.ToPascalCase(repoPkg) + "Repo"
	}
	fieldName := util.ToCamelCase(repoPkg) + "Repo"

	// ensure struct field
	if strings.Contains(src, "type useCase struct") && !strings.Contains(src, fieldName+" "+iface) {
		src = strings.Replace(src,
			"type useCase struct {",
			"type useCase struct {\n\t// ntaps:generated\n\t"+fieldName+" "+iface,
			1,
		)
	}

	// ensure constructor param
	sigRe := regexp.MustCompile(`func\s+NewUseCase\((?s).*?\)\s+UseCase`)
	loc := sigRe.FindStringIndex(src)
	if loc != nil {
		open := strings.Index(src[loc[0]:loc[1]], "(") + loc[0] + 1
		close := strings.LastIndex(src[loc[0]:loc[1]], ")") + loc[0]
		param := fieldName + " " + iface
		if !strings.Contains(src[open:close], param) {
			src = src[:close] + ", " + param + src[close:]
		}
	}

	// ensure struct literal assignment
	newRe := regexp.MustCompile(`return\s+&useCase\{(?s).*?\}`)
	m := newRe.FindStringIndex(src)
	if m != nil {
		body := src[m[0]:m[1]]
		assign := fieldName + ": " + fieldName + ","
		if !strings.Contains(body, assign) {
			body = strings.Replace(body, "{", "{\t"+assign+"\t", 1)
			src = src[:m[0]] + body + src[m[1]:]
		}
	}

	return util.WriteGoFile(path, src)
}

// inject repo arg "s.repo.<Repo>Repo" into s.uc.<Uc>Uc = <uc>.NewUseCase(...)
// inside infrastructure/di/usecase.go
func updateInfraUsecaseInitArgs(ucPkg, repoPkg string) error {
	path := paths.InfraInitUsecasePath

	raw, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read %s: %w", path, err)
	}
	src := string(raw)

	ucField := util.ToPascalCase(ucPkg) + "Uc"
	repoArg := "s.repo." + util.ToPascalCase(repoPkg) + "Repo"

	re := regexp.MustCompile(
		fmt.Sprintf(`s\.uc\.%s\s*=\s*%s\.NewUseCase\(([\s\S]*?)\)`, ucField, ucPkg),
	)
	m := re.FindStringSubmatchIndex(src)
	if m == nil {
		return fmt.Errorf("NewUseCase call for %q not found in %s", ucPkg, path)
	}

	argsStart, argsEnd := m[2], m[3]
	args := src[argsStart:argsEnd]

	if strings.Contains(args, repoArg) {
		return nil
	}

	sep := ""
	if strings.TrimSpace(args) != "" && !strings.HasSuffix(strings.TrimSpace(args), ",") {
		sep = ", "
	}
	newArgs := args + sep + repoArg

	src = src[:argsStart] + newArgs + src[argsEnd:]
	return util.WriteGoFile(path, src)
}
