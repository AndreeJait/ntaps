package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

/* ============================ create-repository ============================ */

func runCreateRepository(pkg, method string, withParamRepo, withRespRepo, withTx bool, addToUC string) error {
	// 1) ensure repo package exists with impl.go skeleton
	if err := ensureRepoPkgPostgres(pkg); err != nil {
		return err
	}

	// 2) ensure dto (param/response) and method implementation exist
	if err := ensureRepoDTO(pkg, method, withParamRepo, withRespRepo); err != nil {
		return err
	}
	if err := ensureRepoMethod(pkg, method, withParamRepo, withRespRepo, withTx); err != nil {
		return err
	}

	// 3) add field in adapters/outbound/db/postgres/di.go
	if err := updatePostgresDI(pkg); err != nil {
		return err
	}

	// 4) wire initRepository() in infrastructure/di/repository.go
	if err := updateInfraRepositoryInit(pkg); err != nil {
		return err
	}

	// 5) optionally wire into a usecase package (interfaces + struct field + ctor)
	if addToUC != "" {
		ucDir := filepath.Join(rootUsecaseDir, addToUC)
		if _, err := os.Stat(ucDir); errors.Is(err, os.ErrNotExist) {
			fmt.Println("ℹ️  repo not added to usecase because usecase is not found:", addToUC)
			return nil
		}
		if err := ensureUsecaseRepoInterface(addToUC, pkg, method, withParamRepo, withRespRepo, withTx); err != nil {
			return err
		}
		if err := ensureUsecaseHasRepo(addToUC, pkg); err != nil {
			return err
		}
		
		// ⬇️ add this to append the new repo arg at the call site
		if err := updateInfraUsecaseInitArgs(addToUC, pkg); err != nil {
			return err
			// (or log and continue if you prefer a soft failure)
			// fmt.Println("ℹ️", err)
		}
	}
	return nil
}

/* ---------- repo package skeleton (postgres) ---------- */

func ensureRepoPkgPostgres(pkg string) error {
	mod := modulePathGuess()
	dir := filepath.Join(repoPgPath, pkg)
	if _, err := os.Stat(dir); errors.Is(err, os.ErrNotExist) {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	impl := filepath.Join(dir, "impl.go")
	if _, err := os.Stat(impl); errors.Is(err, os.ErrNotExist) {
		body := fmt.Sprintf(`package %s

import (
	"context"

	"%[3]s/internal/adapters/outbound/db/postgres/sqlc"
	"github.com/AndreeJait/go-utility/tracer"
	"github.com/jackc/pgx/v5/pgxpool"
)

type Repository struct {
	q *sqlc.Queries
}

func New%[2]sRepository(q *pgxpool.Pool) *Repository {
	return &Repository{q: sqlc.New(q)}
}
`, pkg, toExport(pkg), mod)
		return writeGoFile(impl, body)
	}
	return nil
}

/* ---------- repo dto ---------- */

func ensureRepoDTO(pkg, method string, withParam, withResp bool) error {
	path := filepath.Join(repoPgPath, pkg, "dto.go")
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		if err := writeGoFile(path, "package "+pkg+"\n\n"); err != nil {
			return err
		}
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)
	if withParam {
		decl := fmt.Sprintf("type %sParam struct { \n\t// TODO: define fields\n}\n", method)
		if !strings.Contains(src, "type "+method+"Param struct") {
			src += "\n// generated by ntaps\n" + decl
		}
	}
	if withResp {
		decl := fmt.Sprintf("type %sResponse struct { \n\t// TODO: define fields\n}\n", method)
		if !strings.Contains(src, "type "+method+"Response struct") {
			src += "\n// generated by ntaps\n" + decl
		}
	}
	return writeGoFile(path, src)
}

/* ---------- repo impl method ---------- */

func ensureRepoMethod(pkg, method string, withParam, withResp, withTx bool) error {
	mod := modulePathGuess()
	path := filepath.Join(repoPgPath, pkg, "impl.go")

	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	// Ensure imports
	reqImports := []string{
		`"context"`,
		fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/sqlc"`, mod),
		`"github.com/AndreeJait/go-utility/tracer"`,
	}
	if withTx {
		reqImports = append(reqImports, `"github.com/jackc/pgx/v5"`)
	}
	for _, imp := range reqImports {
		if !strings.Contains(src, imp) {
			src = insertImport(src, imp)
		}
	}

	// Append method if not exists
	sig := fmt.Sprintf("func (r *Repository) %s(", method)
	if strings.Contains(src, sig) {
		return writeGoFile(path, src)
	}

	// build signature
	args := "ctx context.Context"
	if withParam {
		args += fmt.Sprintf(", param %sParam", method)
	}
	if withTx {
		args += ", tx pgx.Tx"
	}

	ret := "error"
	if withResp {
		ret = fmt.Sprintf("(%sResponse, error)", method)
	}

	// body
	qSetup := `
	q := r.q
	if tx != nil {
		q = sqlc.New(tx)
	}
`
	if !withTx {
		qSetup = "\n\tq := r.q\n"
	}

	retBody := "\t// TODO: implement\n\treturn nil"
	if withResp {
		retBody = fmt.Sprintf("\tvar resp %sResponse\n\t// TODO: implement\n\t_ = q\n\treturn resp, nil", method)
	} else {
		retBody = "\t// TODO: implement\n\t_ = q\n\treturn nil"
	}

	methodCode := fmt.Sprintf(`

func (r *Repository) %s(%s) %s {
	span, ctx := tracer.StartSpan(ctx, tracer.GetFuncName(r.%s))
	defer span.End()
	%s
%s
}
`, method, args, ret, method, strings.TrimRight(qSetup, "\n"), retBody)

	src += methodCode
	return writeGoFile(path, src)
}

/* ---------- adapters/outbound/db/postgres/di.go ---------- */

func updatePostgresDI(pkg string) error {
	mod := modulePathGuess()
	path := pgDiPath

	// create minimal di.go if missing
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		content := fmt.Sprintf(`package db

import (
	"%s/internal/adapters/outbound/db/postgres/%s"
	"%s/internal/infrastructure/db"
)

type Repository struct {
	%sRepo *%s.Repository
	TxManager *db.TxManager
}
`, mod, pkg, mod, toExport(pkg), pkg)
		return writeGoFile(path, content)
	}

	// update existing
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	imp := fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, pkg)
	if !strings.Contains(src, imp) {
		src = insertImport(src, imp)
	}
	if !strings.Contains(src, fmt.Sprintf(`"%s/internal/infrastructure/db"`, mod)) {
		src = insertImport(src, fmt.Sprintf(`"%s/internal/infrastructure/db"`, mod))
	}

	field := fmt.Sprintf("\t%sRepo *%s.Repository", toExport(pkg), pkg)
	if !strings.Contains(src, field) {
		src = strings.Replace(src, "type Repository struct {", "type Repository struct {\n"+"\t// "+toExport(pkg)+"Repo\n"+field, 1)
	}
	if !strings.Contains(src, "\tTxManager *db.TxManager") {
		src = strings.Replace(src, "type Repository struct {", "type Repository struct {\n\t// TxManager\n\tTxManager *db.TxManager", 1)
	}
	return writeGoFile(path, src)
}

/* ---------- infrastructure/di/repository.go ---------- */

func updateInfraRepositoryInit(pkg string) error {
	mod := modulePathGuess()
	path := infraRepoInitPath
	if _, err := os.Stat(path); err != nil {
		return fmt.Errorf("cannot find %s (needed to wire initRepository)", path)
	}
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	// imports
	impRepo := fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, pkg)
	if !strings.Contains(src, impRepo) {
		src = insertImport(src, impRepo)
	}
	impDB := fmt.Sprintf(`"%s/internal/infrastructure/db"`, mod)
	if !strings.Contains(src, impDB) {
		src = insertImport(src, impDB)
	}

	// ensure function exists
	if !strings.Contains(src, "func (s wire) initRepository(") && !strings.Contains(src, "func (s wire) initRepository()") {
		src += `

func (s wire) initRepository() {
	// generated by ntaps
}
`
	}

	// inject assignments
	assignRepo := fmt.Sprintf(`s.repo.%sRepo = %s.New%sRepository(s.pg)`, toExport(pkg), pkg, toExport(pkg))
	assignTx := `s.repo.TxManager = db.NewTxManager(s.pg)`

	re := regexp.MustCompile(`func \(s\s+wire\)\s+initRepository\([^\)]*\)\s*\{`)
	loc := re.FindStringIndex(src)
	if loc == nil {
		return fmt.Errorf("initRepository() not found in %s", path)
	}
	insertAt := loc[1]
	if !strings.Contains(src, assignRepo) {
		src = src[:insertAt] + "\n\t// generated by ntaps\n\t" + assignRepo + src[insertAt:]
	}
	if !strings.Contains(src, assignTx) {
		// place after repo assign if present
		idx := strings.Index(src, assignRepo)
		if idx != -1 {
			braceIdx := strings.Index(src[idx:], "\n")
			insertAt = idx + braceIdx + 1
		}
		src = src[:insertAt] + "\t" + assignTx + "\n" + src[insertAt:]
	}

	return writeGoFile(path, src)
}

/* ---------- usecase wiring for repo ---------- */

func ensureUsecaseRepoInterface(ucPkg, repoPkg, method string, withParam, withResp, withTx bool) error {
	mod := modulePathGuess()
	path := filepath.Join(rootUsecaseDir, ucPkg, "port.go")

	// Ensure file exists at least
	if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
		if err := writeGoFile(path, "package "+ucPkg+"\n\nimport \"context\"\n\ntype UseCase interface{}\n"); err != nil {
			return err
		}
	}

	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	// imports required
	impRepo := fmt.Sprintf(`"%s/%s/%s/%s/%s"`, mod, "internal", "adapters", "outbound/db/postgres", repoPkg)
	impRepo = fmt.Sprintf(`"%s/internal/adapters/outbound/db/postgres/%s"`, mod, repoPkg)
	if !strings.Contains(src, impRepo) {
		src = insertImport(src, impRepo)
	}
	if withTx && !strings.Contains(src, `"github.com/jackc/pgx/v5"`) {
		src = insertImport(src, `"github.com/jackc/pgx/v5"`)
	}
	if !strings.Contains(src, `import "context"`) && !strings.Contains(src, "import (") {
		firstNL := strings.Index(src, "\n")
		src = src[:firstNL+1] + `import "context"` + "\n" + src[firstNL+1:]
	}

	// interface name
	iface := "Repo"
	if repoPkg != ucPkg {
		iface = toExport(repoPkg) + "Repo"
	}

	// ensure interface exists
	if !strings.Contains(src, "type "+iface+" interface {") {
		src += "\n" + "type " + iface + " interface {\n}\n"
	}

	// ensure method on that interface
	req := "ctx context.Context"
	if withParam {
		req += fmt.Sprintf(", param %s.%sParam", repoPkg, method)
	}
	if withTx {
		req += ", tx pgx.Tx"
	}
	ret := "error"
	if withResp {
		ret = fmt.Sprintf("(%s.%sResponse, error)", repoPkg, method)
	}
	newLine := fmt.Sprintf("\t%s(%s) %s", method, req, ret)

	// insert inside the iface block
	start := strings.Index(src, "type "+iface+" interface {")
	if start != -1 {
		end := strings.Index(src[start:], "}")
		if end != -1 {
			block := src[start : start+end]
			if !strings.Contains(block, method+"(") {
				insertAt := start + end
				src = src[:insertAt] + "\t// " + method + " \n" + newLine + "\n" + src[insertAt:]
			}
		}
	}

	return writeGoFile(path, src)
}

func ensureUsecaseHasRepo(ucPkg, repoPkg string) error {
	path := filepath.Join(rootUsecaseDir, ucPkg, "usecase.go")
	b, err := os.ReadFile(path)
	if err != nil {
		return err
	}
	src := string(b)

	iface := "Repo"
	if repoPkg != ucPkg {
		iface = toExport(repoPkg) + "Repo"
	}
	fieldName := toCamelCase(repoPkg) + "Repo"

	// ensure struct field
	if strings.Contains(src, "type useCase struct") && !strings.Contains(src, fieldName+" "+iface) {
		src = strings.Replace(src, "type useCase struct {", "type useCase struct {\n\t// ntaps:generated\n\t"+fieldName+" "+iface, 1)
	}

	// ensure constructor param
	sigRe := regexp.MustCompile(`func\s+NewUseCase\((?s).*?\)\s+UseCase`)
	loc := sigRe.FindStringIndex(src)
	if loc != nil {
		// add param if missing
		open := strings.Index(src[loc[0]:loc[1]], "(") + loc[0] + 1
		close := strings.LastIndex(src[loc[0]:loc[1]], ")") + loc[0]
		param := fieldName + " " + iface
		if !strings.Contains(src[open:close], param) {
			src = src[:close] + ", " + param + src[close:]
		}
	}

	// ensure struct literal assignment
	newRe := regexp.MustCompile(`return\s+&useCase\{(?s).*?\}`)
	m := newRe.FindStringIndex(src)
	if m != nil {
		body := src[m[0]:m[1]]
		assign := fieldName + ": " + fieldName + ","
		if !strings.Contains(body, assign) {
			body = strings.Replace(body, "{", "{\t"+assign+"\t", 1)
			src = src[:m[0]] + body + src[m[1]:]
		}
	}

	return writeGoFile(path, src)
}

// append s.repo.<RepoPkg>Repo to the <ucPkg>.NewUseCase(...) call inside
// internal/infrastructure/di/usecase.go (func (s wire) initUseCase()).
func updateInfraUsecaseInitArgs(ucPkg, repoPkg string) error {
	path := infraInitUsecasePath

	b, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read %s: %w", path, err)
	}
	src := string(b)

	ucField := toPascalCase(ucPkg) + "Uc"                 // e.g. send -> SendUc
	callPkg := ucPkg                                      // e.g. send
	repoArg := "s.repo." + toPascalCase(repoPkg) + "Repo" // e.g. User -> s.repo.UserRepo

	// Match: s.uc.SendUc = send.NewUseCase(<args>)
	re := regexp.MustCompile(
		fmt.Sprintf(`s\.uc\.%s\s*=\s*%s\.NewUseCase\(([\s\S]*?)\)`, ucField, callPkg),
	)

	m := re.FindStringSubmatchIndex(src)
	if m == nil {
		return fmt.Errorf("NewUseCase call for %q not found in %s", ucPkg, path)
	}

	// Capture group 1 are the args within (...)
	argsStart, argsEnd := m[2], m[3]
	args := src[argsStart:argsEnd]

	// Already present? nothing to do.
	if strings.Contains(args, repoArg) {
		return nil
	}

	sep := ""
	if strings.TrimSpace(args) != "" && !strings.HasSuffix(strings.TrimSpace(args), ",") {
		sep = ", "
	}
	newArgs := args + sep + repoArg

	src = src[:argsStart] + newArgs + src[argsEnd:]
	return writeGoFile(path, src)
}
